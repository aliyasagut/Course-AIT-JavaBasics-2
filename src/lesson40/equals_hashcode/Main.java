package lesson40.equals_hashcode;

public class Main {
    public static void main(String[] args) {

        Order o1 = new Order(1, "order1");
        Order o2 = new Order(1, "order1");
        Order o3 = new Order(1, "order2");

        System.out.println(o1 == o2); // сравнение по ссылкам
        System.out.println(o1.equals(o2)); // здесь должны бы сравниваться значения, но что-то не так, в конкретном
                                            // случае сравниваются тоже ссылки
        System.out.println(o1.equals(o3));
        System.out.println(o1.hashCode());
    }

    /*
    equals() contract
    1.  reflexive - объект должен быть равен самому себе
    2.  symmetric - x.equals(y) должен возвращать тот же результат, что и y.equals(x)
    3.  transitive - если x.equals(y) и y.equals(z), то и x.equals(z)
    4.  consistent - значение equals() может меняться, только если изменятся значения содержащиеся в нем

    Hashcode это целое число, которое генерируется с помощью алгоритма хеширования

    hashcode() contract
    1.  При вызове на одном и том же объекте  несколько раз во время выполнения программы, метод hashcode() должен
        возвращать одно и то же значение, при условии, что значения полей не менялись. При этом значение не обязателно
        должно оставаться неизменным при нескольких вызовах программы.
    2.  Если два объекта равны в соответствии с методом equals(), то их хешкоды также должны быть одинаковы.
    3.  Если два объекта не равна по equals(), то вызов метода hashcode() для них не обязательно должен возвращать
        разные начения.


    Бинарные деревья
    Структура данных, которая состоит из узлов и строится о следующим правилам:
    1. Каждый узел имеет не более двух детей
    2. Каждое значение меньше значения узла станет левым ребенком или ребенком левого ребенка
    3. Каждое значение больше или равно значению узла станет правым ребенком или ребеком правого ребенка



     */





}
